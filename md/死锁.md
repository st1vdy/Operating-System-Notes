# 死锁

## 基本概念

### 死锁、饥饿和死循环的比较

- **死锁**：死锁的发生至少需要两个进程相互等待，进程处于阻塞态等待资源。
- **饥饿**：饥饿是因为操作系统策略不当，导致某些进程始终无法上处理机运行，可能是就绪态或阻塞态。
- **死循环**：这里的死循环特指程序中的错误编码，这不是操作系统可以解决的问题。

### 必要条件

- **互斥**：必须是进程争用一个互斥资源。
- **占有并等待**：一个进程应占有至少一个资源，并等待另一个资源，等待的资源恰好被其他进程占有。
- **非抢占**：资源不能抢占。
- **循环等待**：有一组等待进程的等待关系恰好构成了一个有向环。

### 发生死锁的情况

- 竞争不可剥夺的资源。
- 进程推进顺序非法。
- 信号量机制错误使用。



## 预防死锁

预防死锁的做法就是：破坏死锁发生的必要条件。

### 互斥

- 如果所有资源都是共享文件就不会产生死锁了。

  比如只读文件就不会产生死锁。

### 持有且等待

- 每个进程申请一个资源前申请并获得所有资源。

  缺点：资源利用率低，可能发生饥饿。

### 无抢占

- 申请的资源得不到满足时，立即释放拥有的所有资源
- 如果一个进程正在等待资源，那么它所拥有的资源都可以被抢占。

### 循环等待

- 给每个资源编号，申请资源时必须按照从小到大的顺序申请。



## 避免死锁

### 银行家算法

假设有 $n$ 个系统进程，$m$ 个系统资源。

- `available[]`：长度为 $m$ 的向量，`available[i] = k` 表示资源 $i$ 有 $k$ 个可用实例。
- `max[][]`：$n\times m$ 的矩阵，`max[i][j] = k` 表示进程 $P_i$ 最多可申请 $k$ 个资源 $j$ 的实例。
- `allocation[][]`：$n\times m$ 的矩阵，`allocation[i][j] = k` 表示进程 $i$ 已经占有了 $k$ 个资源 $j$ 的实例。
- `need[][]`：$n\times m$ 的矩阵，`need[i][j] = k` 表示进程 $i$ 还需要 $k$ 个资源 $j$ 的实例。根据定义明显有 `need[i][j] = max[i][j] = allocation[i][j]`。

#### 安全算法

定义 `work[]` 和 `finish[]` 分别是长度为 $m$ 和 $n$ 的向量，初值为 `work = available, finish = false`。

1. 查找这样的 $i$ 使其满足

   - `finish[i] == false`
   - `need[i] <= work`

   如果不存在，跳转到第3步。

2. `work = work + allocation[i], finish[i] = true`，跳回步骤1。

3. 如果所有 $i$ 均满足 `finish[i] == true`，那么系统处于安全状态。

最劣时间复杂度 $O(MN^2)$。

*本质上就是：循环查找不安全的向量，并更新数据。

- 安全性算法是检查系统是否处于不安全状态（如果所有进程都可以完成并终止，则一个状态被认为是安全的），并不是真正在检测系统是否处于死锁状态。

#### 资源请求算法



## 死锁检测

检测到死锁后，解除的方法是：

1. **资源剥夺法**。挂起某些死锁进程，并抢占他们的资源分配给其他的死锁进程。
2. **撤销进程法**。强制撤销部分死锁进程，并抢占他们的资源。
3. **进程回退法**。让一个或多个死锁进程回退到足以避免死锁的地步，这需要系统设置一些存档，记录历史信息。



## 例题

> 下列关于死锁的叙述中，正确的是（）
>
> 1. 可以通过剥夺进程资源解除死锁
> 2. 死锁的预防方法能确保系统不发生死锁
> 3. 银行家算法可以判断系统是否处于死锁状态
> 4. 当系统出现死锁时，必然有两个或两个以上的进程处于阻塞态。

选项1，2，4正确。

选项3，银行家算法只能判断系统是否处于安全状态，而不是判断是否发生了死锁。



> 